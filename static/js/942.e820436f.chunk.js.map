{"version":3,"file":"static/js/942.e820436f.chunk.js","mappings":"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","sources":["services/adoAnalyticsService.ts"],"sourcesContent":["// Azure DevOps Analytics OData Service\r\n// Leverages prebuilt calculations and server-side aggregations for optimal performance\r\n\r\nexport interface AnalyticsWorkItem {\r\n  WorkItemId: number;\r\n  Title: string;\r\n  WorkItemType: string;\r\n  State: string;\r\n  AssignedToUserName?: string;\r\n  CreatedDate: string;\r\n  ChangedDate: string;\r\n  ClosedDate?: string;\r\n  ResolvedDate?: string;\r\n  ActivatedDate?: string;\r\n  StateChangeDate?: string;\r\n  IterationPath: string;\r\n  AreaPath: string;\r\n  StoryPoints?: number;\r\n  Priority?: number;\r\n  \r\n  // ADO Pre-calculated fields\r\n  CycleTimeDays?: number;\r\n  LeadTimeDays?: number;\r\n  Age?: number;\r\n  DateSK: number; // Date dimension key (YYYYMMDD)\r\n  \r\n  // State categories (pre-mapped)\r\n  StateCategory: 'Proposed' | 'InProgress' | 'Resolved' | 'Completed' | 'Removed';\r\n  \r\n  // Additional analytics fields\r\n  CompletedWork?: number;\r\n  RemainingWork?: number;\r\n  OriginalEstimate?: number;\r\n  BusinessValue?: number;\r\n  Risk?: string;\r\n  Severity?: string;\r\n  ValueArea?: string;\r\n  BoardColumn?: string;\r\n  Tags?: string;\r\n}\r\n\r\nexport interface AnalyticsSnapshot {\r\n  WorkItemId: number;\r\n  Date: string;\r\n  DateSK: number;\r\n  State: string;\r\n  StateCategory: string;\r\n  StoryPoints?: number;\r\n  CycleTimeDays?: number;\r\n  LeadTimeDays?: number;\r\n  IsLastRevisionOfDay: boolean;\r\n}\r\n\r\nexport interface AnalyticsAggregation {\r\n  totalItems: number;\r\n  completedItems: number;\r\n  totalStoryPoints: number;\r\n  completedStoryPoints: number;\r\n  avgCycleTime: number;\r\n  avgLeadTime: number;\r\n  p50CycleTime: number;\r\n  p85CycleTime: number;\r\n  p95CycleTime: number;\r\n  throughputByWeek: Array<{\r\n    weekStartDate: string;\r\n    itemsCompleted: number;\r\n    storyPointsCompleted: number;\r\n  }>;\r\n  velocityTrend: Array<{\r\n    iterationPath: string;\r\n    storyPointsCompleted: number;\r\n    itemsCompleted: number;\r\n  }>;\r\n}\r\n\r\nexport interface AnalyticsResult<T> {\r\n  success: boolean;\r\n  data?: T;\r\n  error?: string;\r\n  count?: number;\r\n}\r\n\r\nclass AdoAnalyticsService {\r\n  private getAnalyticsBaseUrl(organization: string): string {\r\n    return `https://analytics.dev.azure.com/${organization}/_odata/v4.0-preview`;\r\n  }\r\n\r\n  private getAuthHeaders(pat: string): Record<string, string> {\r\n    return {\r\n      'Authorization': `Basic ${btoa(`:${pat}`)}`,\r\n      'Content-Type': 'application/json',\r\n      'Accept': 'application/json'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Fetch work items with pre-calculated analytics fields\r\n   */\r\n  async fetchAnalyticsWorkItems(\r\n    organization: string,\r\n    project: string,\r\n    pat: string,\r\n    areaPath?: string,\r\n    dateRange?: { startDate: string; endDate: string }\r\n  ): Promise<AnalyticsResult<AnalyticsWorkItem[]>> {\r\n    try {\r\n      const baseUrl = this.getAnalyticsBaseUrl(organization);\r\n      const headers = this.getAuthHeaders(pat);\r\n\r\n      // Build OData filter\r\n      let filter = `Project/ProjectName eq '${project}'`;\r\n      \r\n      if (areaPath) {\r\n        filter += ` and startswith(AreaPath, '${project}\\\\${areaPath}')`;\r\n      }\r\n      \r\n      if (dateRange) {\r\n        const startDateSK = parseInt(dateRange.startDate.replace(/-/g, ''));\r\n        const endDateSK = parseInt(dateRange.endDate.replace(/-/g, ''));\r\n        filter += ` and DateSK ge ${startDateSK} and DateSK le ${endDateSK}`;\r\n      }\r\n\r\n      // Select pre-calculated fields from Analytics\r\n      const select = [\r\n        'WorkItemId',\r\n        'Title',\r\n        'WorkItemType',\r\n        'State',\r\n        'StateCategory',\r\n        'AssignedToUserName',\r\n        'CreatedDate',\r\n        'ChangedDate',\r\n        'ClosedDate',\r\n        'ResolvedDate',\r\n        'ActivatedDate',\r\n        'StateChangeDate',\r\n        'IterationPath',\r\n        'AreaPath',\r\n        'StoryPoints',\r\n        'Priority',\r\n        'CycleTimeDays',    // Pre-calculated by ADO\r\n        'LeadTimeDays',     // Pre-calculated by ADO\r\n        'Age',              // Pre-calculated by ADO\r\n        'DateSK',\r\n        'CompletedWork',\r\n        'RemainingWork',\r\n        'OriginalEstimate',\r\n        'BusinessValue',\r\n        'Risk',\r\n        'Severity',\r\n        'ValueArea',\r\n        'BoardColumn',\r\n        'Tags'\r\n      ].join(',');\r\n\r\n      const url = `${baseUrl}/WorkItems?$filter=${encodeURIComponent(filter)}&$select=${select}&$orderby=ChangedDate desc`;\r\n      \r\n      console.log('🔧 Analytics API: Fetching work items with pre-calculated fields:', url);\r\n\r\n      const response = await fetch(url, { headers });\r\n\r\n      if (!response.ok) {\r\n        return {\r\n          success: false,\r\n          error: `Analytics API failed: ${response.status} ${response.statusText}`\r\n        };\r\n      }\r\n\r\n      const data = await response.json();\r\n      \r\n      return {\r\n        success: true,\r\n        data: data.value || [],\r\n        count: data.value?.length || 0\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch historical snapshots for trend analysis\r\n   */\r\n  async fetchWorkItemSnapshots(\r\n    organization: string,\r\n    project: string,\r\n    pat: string,\r\n    areaPath?: string,\r\n    dateRange?: { startDate: string; endDate: string }\r\n  ): Promise<AnalyticsResult<AnalyticsSnapshot[]>> {\r\n    try {\r\n      const baseUrl = this.getAnalyticsBaseUrl(organization);\r\n      const headers = this.getAuthHeaders(pat);\r\n\r\n      let filter = `Project/ProjectName eq '${project}' and IsLastRevisionOfDay eq true`;\r\n      \r\n      if (areaPath) {\r\n        filter += ` and startswith(AreaPath, '${project}\\\\${areaPath}')`;\r\n      }\r\n      \r\n      if (dateRange) {\r\n        const startDateSK = parseInt(dateRange.startDate.replace(/-/g, ''));\r\n        const endDateSK = parseInt(dateRange.endDate.replace(/-/g, ''));\r\n        filter += ` and DateSK ge ${startDateSK} and DateSK le ${endDateSK}`;\r\n      }\r\n\r\n      const select = [\r\n        'WorkItemId',\r\n        'Date',\r\n        'DateSK',\r\n        'State',\r\n        'StateCategory',\r\n        'StoryPoints',\r\n        'CycleTimeDays',\r\n        'LeadTimeDays',\r\n        'IsLastRevisionOfDay'\r\n      ].join(',');\r\n\r\n      const url = `${baseUrl}/WorkItemSnapshot?$filter=${encodeURIComponent(filter)}&$select=${select}&$orderby=DateSK desc`;\r\n      \r\n      console.log('🔧 Analytics API: Fetching historical snapshots:', url);\r\n\r\n      const response = await fetch(url, { headers });\r\n\r\n      if (!response.ok) {\r\n        return {\r\n          success: false,\r\n          error: `Analytics snapshots failed: ${response.status} ${response.statusText}`\r\n        };\r\n      }\r\n\r\n      const data = await response.json();\r\n      \r\n      return {\r\n        success: true,\r\n        data: data.value || [],\r\n        count: data.value?.length || 0\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get server-side aggregated analytics\r\n   */\r\n  async fetchAggregatedAnalytics(\r\n    organization: string,\r\n    project: string,\r\n    pat: string,\r\n    areaPath?: string,\r\n    dateRange?: { startDate: string; endDate: string }\r\n  ): Promise<AnalyticsResult<AnalyticsAggregation>> {\r\n    try {\r\n      const baseUrl = this.getAnalyticsBaseUrl(organization);\r\n      const headers = this.getAuthHeaders(pat);\r\n\r\n      // Build base filter\r\n      let baseFilter = `Project/ProjectName eq '${project}'`;\r\n      \r\n      if (areaPath) {\r\n        baseFilter += ` and startswith(AreaPath, '${project}\\\\${areaPath}')`;\r\n      }\r\n      \r\n      if (dateRange) {\r\n        const startDateSK = parseInt(dateRange.startDate.replace(/-/g, ''));\r\n        const endDateSK = parseInt(dateRange.endDate.replace(/-/g, ''));\r\n        baseFilter += ` and DateSK ge ${startDateSK} and DateSK le ${endDateSK}`;\r\n      }\r\n\r\n      // Parallel requests for different aggregations\r\n      const requests = [\r\n        // Basic counts and totals\r\n        fetch(`${baseUrl}/WorkItems?$filter=${encodeURIComponent(baseFilter)}&$apply=aggregate($count as TotalItems, StoryPoints with sum as TotalStoryPoints)`, { headers }),\r\n        \r\n        // Completed items\r\n        fetch(`${baseUrl}/WorkItems?$filter=${encodeURIComponent(baseFilter + ` and StateCategory eq 'Completed'`)}&$apply=aggregate($count as CompletedItems, StoryPoints with sum as CompletedStoryPoints)`, { headers }),\r\n        \r\n        // Cycle time percentiles (server-side calculation)\r\n        fetch(`${baseUrl}/WorkItems?$filter=${encodeURIComponent(baseFilter + ` and CycleTimeDays ne null`)}&$apply=aggregate(CycleTimeDays with average as AvgCycleTime)`, { headers }),\r\n        \r\n        // Lead time average\r\n        fetch(`${baseUrl}/WorkItems?$filter=${encodeURIComponent(baseFilter + ` and LeadTimeDays ne null`)}&$apply=aggregate(LeadTimeDays with average as AvgLeadTime)`, { headers }),\r\n        \r\n        // Weekly throughput\r\n        fetch(`${baseUrl}/WorkItems?$filter=${encodeURIComponent(baseFilter + ` and StateCategory eq 'Completed'`)}&$apply=groupby((CompletedDateSK),aggregate($count as ItemsCompleted, StoryPoints with sum as StoryPointsCompleted))&$orderby=CompletedDateSK desc&$top=12`, { headers }),\r\n        \r\n        // Velocity by iteration\r\n        fetch(`${baseUrl}/WorkItems?$filter=${encodeURIComponent(baseFilter + ` and StateCategory eq 'Completed'`)}&$apply=groupby((IterationPath),aggregate($count as ItemsCompleted, StoryPoints with sum as StoryPointsCompleted))&$orderby=StoryPointsCompleted desc&$top=10`, { headers })\r\n      ];\r\n\r\n      console.log('🔧 Analytics API: Fetching server-side aggregations...');\r\n\r\n      const responses = await Promise.all(requests);\r\n      \r\n      // Check if all requests succeeded\r\n      for (let i = 0; i < responses.length; i++) {\r\n        if (!responses[i].ok) {\r\n          console.warn(`Analytics aggregation request ${i} failed:`, responses[i].statusText);\r\n        }\r\n      }\r\n\r\n      const [\r\n        totalData,\r\n        completedData,\r\n        cycleTimeData,\r\n        leadTimeData,\r\n        throughputData,\r\n        velocityData\r\n      ] = await Promise.all(responses.map(r => r.ok ? r.json() : { value: [] }));\r\n\r\n      // Process results\r\n      const totals = totalData.value?.[0] || { TotalItems: 0, TotalStoryPoints: 0 };\r\n      const completed = completedData.value?.[0] || { CompletedItems: 0, CompletedStoryPoints: 0 };\r\n      const cycleTime = cycleTimeData.value?.[0] || { AvgCycleTime: 0 };\r\n      const leadTime = leadTimeData.value?.[0] || { AvgLeadTime: 0 };\r\n\r\n      // Process weekly throughput\r\n      const throughputByWeek = (throughputData.value || []).map((item: any) => ({\r\n        weekStartDate: this.convertDateSKToDate(item.CompletedDateSK),\r\n        itemsCompleted: item.ItemsCompleted || 0,\r\n        storyPointsCompleted: item.StoryPointsCompleted || 0\r\n      }));\r\n\r\n      // Process velocity trend\r\n      const velocityTrend = (velocityData.value || []).map((item: any) => ({\r\n        iterationPath: item.IterationPath || 'Unknown',\r\n        storyPointsCompleted: item.StoryPointsCompleted || 0,\r\n        itemsCompleted: item.ItemsCompleted || 0\r\n      }));\r\n\r\n      const aggregation: AnalyticsAggregation = {\r\n        totalItems: totals.TotalItems || 0,\r\n        completedItems: completed.CompletedItems || 0,\r\n        totalStoryPoints: totals.TotalStoryPoints || 0,\r\n        completedStoryPoints: completed.CompletedStoryPoints || 0,\r\n        avgCycleTime: cycleTime.AvgCycleTime || 0,\r\n        avgLeadTime: leadTime.AvgLeadTime || 0,\r\n        p50CycleTime: 0, // Would need additional query for percentiles\r\n        p85CycleTime: 0,\r\n        p95CycleTime: 0,\r\n        throughputByWeek,\r\n        velocityTrend\r\n      };\r\n\r\n      return {\r\n        success: true,\r\n        data: aggregation\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cycle time percentiles using server-side calculations\r\n   */\r\n  async fetchCycleTimePercentiles(\r\n    organization: string,\r\n    project: string,\r\n    pat: string,\r\n    areaPath?: string,\r\n    dateRange?: { startDate: string; endDate: string }\r\n  ): Promise<AnalyticsResult<{ p50: number; p85: number; p95: number }>> {\r\n    try {\r\n      const baseUrl = this.getAnalyticsBaseUrl(organization);\r\n      const headers = this.getAuthHeaders(pat);\r\n\r\n      let filter = `Project/ProjectName eq '${project}' and CycleTimeDays ne null and StateCategory eq 'Completed'`;\r\n      \r\n      if (areaPath) {\r\n        filter += ` and startswith(AreaPath, '${project}\\\\${areaPath}')`;\r\n      }\r\n      \r\n      if (dateRange) {\r\n        const startDateSK = parseInt(dateRange.startDate.replace(/-/g, ''));\r\n        const endDateSK = parseInt(dateRange.endDate.replace(/-/g, ''));\r\n        filter += ` and DateSK ge ${startDateSK} and DateSK le ${endDateSK}`;\r\n      }\r\n\r\n      // Get all cycle times for percentile calculation\r\n      const url = `${baseUrl}/WorkItems?$filter=${encodeURIComponent(filter)}&$select=CycleTimeDays&$orderby=CycleTimeDays`;\r\n      \r\n      const response = await fetch(url, { headers });\r\n\r\n      if (!response.ok) {\r\n        return {\r\n          success: false,\r\n          error: `Cycle time percentiles failed: ${response.status} ${response.statusText}`\r\n        };\r\n      }\r\n\r\n      const data = await response.json();\r\n      const cycleTimes = (data.value || []).map((item: any) => item.CycleTimeDays).filter((time: number) => time > 0);\r\n      \r\n      if (cycleTimes.length === 0) {\r\n        return {\r\n          success: true,\r\n          data: { p50: 0, p85: 0, p95: 0 }\r\n        };\r\n      }\r\n\r\n      // Calculate percentiles\r\n      const getPercentile = (arr: number[], percentile: number) => {\r\n        const index = Math.ceil((percentile / 100) * arr.length) - 1;\r\n        return arr[Math.max(0, index)];\r\n      };\r\n\r\n      return {\r\n        success: true,\r\n        data: {\r\n          p50: getPercentile(cycleTimes, 50),\r\n          p85: getPercentile(cycleTimes, 85),\r\n          p95: getPercentile(cycleTimes, 95)\r\n        }\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert DateSK (YYYYMMDD) to readable date\r\n   */\r\n  private convertDateSKToDate(dateSK: number): string {\r\n    const dateStr = dateSK.toString();\r\n    const year = dateStr.substring(0, 4);\r\n    const month = dateStr.substring(4, 6);\r\n    const day = dateStr.substring(6, 8);\r\n    return `${year}-${month}-${day}`;\r\n  }\r\n\r\n  /**\r\n   * Test Analytics API connection\r\n   */\r\n  async testAnalyticsConnection(\r\n    organization: string,\r\n    project: string,\r\n    pat: string\r\n  ): Promise<{ success: boolean; error?: string }> {\r\n    try {\r\n      const baseUrl = this.getAnalyticsBaseUrl(organization);\r\n      const headers = this.getAuthHeaders(pat);\r\n\r\n      const response = await fetch(\r\n        `${baseUrl}/WorkItems?$filter=Project/ProjectName eq '${project}'&$top=1&$select=WorkItemId`,\r\n        { headers }\r\n      );\r\n\r\n      if (!response.ok) {\r\n        return {\r\n          success: false,\r\n          error: `Analytics API connection failed: ${response.status} ${response.statusText}`\r\n        };\r\n      }\r\n\r\n      return { success: true };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch team member metrics using server-side aggregations\r\n   */\r\n  async fetchTeamMemberMetrics(\r\n    organization: string,\r\n    project: string,\r\n    pat: string,\r\n    areaPath?: string,\r\n    dateRange?: { startDate: string; endDate: string }\r\n  ): Promise<AnalyticsResult<Array<{\r\n    assignedTo: string;\r\n    totalItems: number;\r\n    completedItems: number;\r\n    activeItems: number;\r\n    totalStoryPoints: number;\r\n    completedStoryPoints: number;\r\n    avgCycleTime: number;\r\n    avgLeadTime: number;\r\n    completionRate: number;\r\n  }>>> {\r\n    try {\r\n      const baseUrl = this.getAnalyticsBaseUrl(organization);\r\n      const headers = this.getAuthHeaders(pat);\r\n\r\n      // Build OData filter\r\n      let filter = `Project/ProjectName eq '${project}' and AssignedToUserName ne null`;\r\n      \r\n      if (areaPath) {\r\n        filter += ` and startswith(AreaPath, '${project}\\\\${areaPath}')`;\r\n      }\r\n      \r\n      if (dateRange) {\r\n        const startDateSK = parseInt(dateRange.startDate.replace(/-/g, ''));\r\n        const endDateSK = parseInt(dateRange.endDate.replace(/-/g, ''));\r\n        filter += ` and DateSK ge ${startDateSK} and DateSK le ${endDateSK}`;\r\n      }\r\n\r\n      // Server-side grouping by assignee with aggregations\r\n      const apply = `groupby((AssignedToUserName),aggregate(\r\n        $count as TotalItems,\r\n        StoryPoints with sum as TotalStoryPoints,\r\n        CycleTimeDays with average as AvgCycleTime,\r\n        LeadTimeDays with average as AvgLeadTime\r\n      ))`;\r\n\r\n      const url = `${baseUrl}/WorkItems?$filter=${encodeURIComponent(filter)}&$apply=${encodeURIComponent(apply)}`;\r\n      \r\n      console.log('Analytics API: Fetching team member metrics with server-side grouping:', url);\r\n\r\n      const response = await fetch(url, { headers });\r\n\r\n      if (!response.ok) {\r\n        return {\r\n          success: false,\r\n          error: `Analytics API failed: ${response.status} ${response.statusText}`\r\n        };\r\n      }\r\n\r\n      const data = await response.json();\r\n      \r\n      // Transform the grouped data\r\n      const teamMetrics = (data.value || []).map((group: any) => ({\r\n        assignedTo: group.AssignedToUserName || 'Unassigned',\r\n        totalItems: group.TotalItems || 0,\r\n        completedItems: 0, // Will need separate query for completed items\r\n        activeItems: 0, // Will need separate query for active items\r\n        totalStoryPoints: group.TotalStoryPoints || 0,\r\n        completedStoryPoints: 0, // Will need separate query for completed story points\r\n        avgCycleTime: group.AvgCycleTime || 0,\r\n        avgLeadTime: group.AvgLeadTime || 0,\r\n        completionRate: 0 // Will be calculated after getting completed items\r\n      }));\r\n\r\n      // Fetch completed items count for each team member\r\n      for (const member of teamMetrics) {\r\n        try {\r\n          let completedFilter = `Project/ProjectName eq '${project}' and AssignedToUserName eq '${member.assignedTo}' and StateCategory eq 'Completed'`;\r\n          \r\n          if (areaPath) {\r\n            completedFilter += ` and startswith(AreaPath, '${project}\\\\${areaPath}')`;\r\n          }\r\n          \r\n          if (dateRange) {\r\n            const startDateSK = parseInt(dateRange.startDate.replace(/-/g, ''));\r\n            const endDateSK = parseInt(dateRange.endDate.replace(/-/g, ''));\r\n            completedFilter += ` and DateSK ge ${startDateSK} and DateSK le ${endDateSK}`;\r\n          }\r\n\r\n          const completedApply = `aggregate($count as CompletedItems, StoryPoints with sum as CompletedStoryPoints)`;\r\n          const completedUrl = `${baseUrl}/WorkItems?$filter=${encodeURIComponent(completedFilter)}&$apply=${encodeURIComponent(completedApply)}`;\r\n          \r\n          const completedResponse = await fetch(completedUrl, { headers });\r\n          if (completedResponse.ok) {\r\n            const completedData = await completedResponse.json();\r\n            if (completedData.value && completedData.value.length > 0) {\r\n              member.completedItems = completedData.value[0].CompletedItems || 0;\r\n              member.completedStoryPoints = completedData.value[0].CompletedStoryPoints || 0;\r\n            }\r\n          }\r\n\r\n          // Fetch active items count\r\n          let activeFilter = `Project/ProjectName eq '${project}' and AssignedToUserName eq '${member.assignedTo}' and StateCategory eq 'InProgress'`;\r\n          \r\n          if (areaPath) {\r\n            activeFilter += ` and startswith(AreaPath, '${project}\\\\${areaPath}')`;\r\n          }\r\n          \r\n          if (dateRange) {\r\n            const startDateSK = parseInt(dateRange.startDate.replace(/-/g, ''));\r\n            const endDateSK = parseInt(dateRange.endDate.replace(/-/g, ''));\r\n            activeFilter += ` and DateSK ge ${startDateSK} and DateSK le ${endDateSK}`;\r\n          }\r\n\r\n          const activeApply = `aggregate($count as ActiveItems)`;\r\n          const activeUrl = `${baseUrl}/WorkItems?$filter=${encodeURIComponent(activeFilter)}&$apply=${encodeURIComponent(activeApply)}`;\r\n          \r\n          const activeResponse = await fetch(activeUrl, { headers });\r\n          if (activeResponse.ok) {\r\n            const activeData = await activeResponse.json();\r\n            if (activeData.value && activeData.value.length > 0) {\r\n              member.activeItems = activeData.value[0].ActiveItems || 0;\r\n            }\r\n          }\r\n\r\n          // Calculate completion rate\r\n          member.completionRate = member.totalItems > 0 ? (member.completedItems / member.totalItems) * 100 : 0;\r\n        } catch (error) {\r\n          console.warn(`Failed to fetch additional metrics for ${member.assignedTo}:`, error);\r\n        }\r\n      }\r\n      \r\n      return {\r\n        success: true,\r\n        data: teamMetrics,\r\n        count: teamMetrics.length\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch velocity trends using server-side grouping by iteration\r\n   */\r\n  async fetchVelocityTrends(\r\n    organization: string,\r\n    project: string,\r\n    pat: string,\r\n    areaPath?: string,\r\n    dateRange?: { startDate: string; endDate: string }\r\n  ): Promise<AnalyticsResult<Array<{\r\n    iterationPath: string;\r\n    storyPointsCompleted: number;\r\n    itemsCompleted: number;\r\n    startDate: string;\r\n    endDate: string;\r\n  }>>> {\r\n    try {\r\n      const baseUrl = this.getAnalyticsBaseUrl(organization);\r\n      const headers = this.getAuthHeaders(pat);\r\n\r\n      // Build OData filter for completed items\r\n      let filter = `Project/ProjectName eq '${project}' and StateCategory eq 'Completed'`;\r\n      \r\n      if (areaPath) {\r\n        filter += ` and startswith(AreaPath, '${project}\\\\${areaPath}')`;\r\n      }\r\n      \r\n      if (dateRange) {\r\n        const startDateSK = parseInt(dateRange.startDate.replace(/-/g, ''));\r\n        const endDateSK = parseInt(dateRange.endDate.replace(/-/g, ''));\r\n        filter += ` and DateSK ge ${startDateSK} and DateSK le ${endDateSK}`;\r\n      }\r\n\r\n      // Server-side grouping by iteration with aggregations\r\n      const apply = `groupby((IterationPath),aggregate(\r\n        $count as ItemsCompleted,\r\n        StoryPoints with sum as StoryPointsCompleted\r\n      ))`;\r\n\r\n      const url = `${baseUrl}/WorkItems?$filter=${encodeURIComponent(filter)}&$apply=${encodeURIComponent(apply)}&$orderby=IterationPath`;\r\n      \r\n      console.log('Analytics API: Fetching velocity trends with server-side grouping:', url);\r\n\r\n      const response = await fetch(url, { headers });\r\n\r\n      if (!response.ok) {\r\n        return {\r\n          success: false,\r\n          error: `Analytics API failed: ${response.status} ${response.statusText}`\r\n        };\r\n      }\r\n\r\n      const data = await response.json();\r\n      \r\n      // Transform the grouped data\r\n      const velocityTrends = (data.value || []).map((group: any) => ({\r\n        iterationPath: group.IterationPath || 'Unknown',\r\n        storyPointsCompleted: group.StoryPointsCompleted || 0,\r\n        itemsCompleted: group.ItemsCompleted || 0,\r\n        startDate: '', // Would need additional query to get iteration dates\r\n        endDate: ''\r\n      }));\r\n      \r\n      return {\r\n        success: true,\r\n        data: velocityTrends,\r\n        count: velocityTrends.length\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch throughput analysis using server-side date grouping\r\n   */\r\n  async fetchThroughputAnalysis(\r\n    organization: string,\r\n    project: string,\r\n    pat: string,\r\n    areaPath?: string,\r\n    dateRange?: { startDate: string; endDate: string }\r\n  ): Promise<AnalyticsResult<Array<{\r\n    weekStartDate: string;\r\n    itemsCompleted: number;\r\n    storyPointsCompleted: number;\r\n  }>>> {\r\n    try {\r\n      const baseUrl = this.getAnalyticsBaseUrl(organization);\r\n      const headers = this.getAuthHeaders(pat);\r\n\r\n      // Build OData filter for completed items\r\n      let filter = `Project/ProjectName eq '${project}' and StateCategory eq 'Completed' and ClosedDate ne null`;\r\n      \r\n      if (areaPath) {\r\n        filter += ` and startswith(AreaPath, '${project}\\\\${areaPath}')`;\r\n      }\r\n      \r\n      if (dateRange) {\r\n        filter += ` and ClosedDate ge ${dateRange.startDate}Z and ClosedDate le ${dateRange.endDate}Z`;\r\n      }\r\n\r\n      // Server-side grouping by week using ClosedDate\r\n      const apply = `groupby((year(ClosedDate), weekofyear(ClosedDate)),aggregate(\r\n        $count as ItemsCompleted,\r\n        StoryPoints with sum as StoryPointsCompleted\r\n      ))`;\r\n\r\n      const url = `${baseUrl}/WorkItems?$filter=${encodeURIComponent(filter)}&$apply=${encodeURIComponent(apply)}`;\r\n      \r\n      console.log('Analytics API: Fetching throughput analysis with server-side date grouping:', url);\r\n\r\n      const response = await fetch(url, { headers });\r\n\r\n      if (!response.ok) {\r\n        return {\r\n          success: false,\r\n          error: `Analytics API failed: ${response.status} ${response.statusText}`\r\n        };\r\n      }\r\n\r\n      const data = await response.json();\r\n      \r\n      // Transform the grouped data\r\n      const throughputData = (data.value || []).map((group: any) => ({\r\n        weekStartDate: `${group.year || new Date().getFullYear()}-W${group.weekofyear || 1}`,\r\n        itemsCompleted: group.ItemsCompleted || 0,\r\n        storyPointsCompleted: group.StoryPointsCompleted || 0\r\n      }));\r\n      \r\n      return {\r\n        success: true,\r\n        data: throughputData,\r\n        count: throughputData.length\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch work item aging analysis using server-side calculations\r\n   */\r\n  async fetchAgingAnalysis(\r\n    organization: string,\r\n    project: string,\r\n    pat: string,\r\n    areaPath?: string\r\n  ): Promise<AnalyticsResult<Array<{\r\n    ageRange: string;\r\n    count: number;\r\n    avgStoryPoints: number;\r\n  }>>> {\r\n    try {\r\n      const baseUrl = this.getAnalyticsBaseUrl(organization);\r\n      const headers = this.getAuthHeaders(pat);\r\n\r\n      // Build OData filter for non-completed items\r\n      let filter = `Project/ProjectName eq '${project}' and StateCategory ne 'Completed' and Age gt 0`;\r\n      \r\n      if (areaPath) {\r\n        filter += ` and startswith(AreaPath, '${project}\\\\${areaPath}')`;\r\n      }\r\n\r\n      // Server-side grouping by age ranges\r\n      const apply = `groupby((\r\n        case(Age le 7: '0-7 days',\r\n             Age le 14: '8-14 days', \r\n             Age le 30: '15-30 days',\r\n             Age le 60: '31-60 days',\r\n             '60+ days')\r\n      ),aggregate(\r\n        $count as Count,\r\n        StoryPoints with average as AvgStoryPoints\r\n      ))`;\r\n\r\n      const url = `${baseUrl}/WorkItems?$filter=${encodeURIComponent(filter)}&$apply=${encodeURIComponent(apply)}`;\r\n      \r\n      console.log('Analytics API: Fetching aging analysis with server-side age grouping:', url);\r\n\r\n      const response = await fetch(url, { headers });\r\n\r\n      if (!response.ok) {\r\n        return {\r\n          success: false,\r\n          error: `Analytics API failed: ${response.status} ${response.statusText}`\r\n        };\r\n      }\r\n\r\n      const data = await response.json();\r\n      \r\n      // Transform the grouped data\r\n      const agingData = (data.value || []).map((group: any) => ({\r\n        ageRange: group.ageRange || 'Unknown',\r\n        count: group.Count || 0,\r\n        avgStoryPoints: group.AvgStoryPoints || 0\r\n      }));\r\n      \r\n      return {\r\n        success: true,\r\n        data: agingData,\r\n        count: agingData.length\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nexport const adoAnalyticsService = new AdoAnalyticsService(); "],"names":["adoAnalyticsService","getAnalyticsBaseUrl","organization","concat","getAuthHeaders","pat","btoa","fetchAnalyticsWorkItems","project","areaPath","dateRange","_data$value","baseUrl","this","headers","filter","startDateSK","parseInt","startDate","replace","endDateSK","endDate","select","join","url","encodeURIComponent","console","log","response","fetch","ok","success","error","status","statusText","data","json","value","count","length","Error","message","fetchWorkItemSnapshots","_data$value2","fetchAggregatedAnalytics","_totalData$value","_completedData$value","_cycleTimeData$value","_leadTimeData$value","baseFilter","requests","responses","Promise","all","i","warn","totalData","completedData","cycleTimeData","leadTimeData","throughputData","velocityData","map","r","totals","TotalItems","TotalStoryPoints","completed","CompletedItems","CompletedStoryPoints","cycleTime","AvgCycleTime","leadTime","AvgLeadTime","throughputByWeek","item","weekStartDate","convertDateSKToDate","CompletedDateSK","itemsCompleted","ItemsCompleted","storyPointsCompleted","StoryPointsCompleted","velocityTrend","iterationPath","IterationPath","totalItems","completedItems","totalStoryPoints","completedStoryPoints","avgCycleTime","avgLeadTime","p50CycleTime","p85CycleTime","p95CycleTime","fetchCycleTimePercentiles","cycleTimes","CycleTimeDays","time","p50","p85","p95","getPercentile","arr","percentile","index","Math","ceil","max","dateSK","dateStr","toString","year","substring","month","day","testAnalyticsConnection","fetchTeamMemberMetrics","apply","teamMetrics","group","assignedTo","AssignedToUserName","activeItems","completionRate","member","completedFilter","completedApply","completedUrl","completedResponse","activeFilter","activeApply","activeUrl","activeResponse","activeData","ActiveItems","fetchVelocityTrends","velocityTrends","fetchThroughputAnalysis","Date","getFullYear","weekofyear","fetchAgingAnalysis","agingData","ageRange","Count","avgStoryPoints","AvgStoryPoints"],"sourceRoot":""}